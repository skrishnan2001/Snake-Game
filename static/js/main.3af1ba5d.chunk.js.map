{"version":3,"sources":["Board/Board.jsx","lib/utils.js","App.js","reportWebVitals.js","index.js"],"names":["LinkedListNode","value","this","next","LinkedList","node","head","tail","Direction","getStartingSnakeLLValue","board","rowSize","length","colSize","startingRow","Math","round","startingCol","row","col","cell","createBoard","BOARD_SIZE","counter","currentRow","push","getCoordsInDirection","coords","direction","isOutOfBounds","getDirectionFromKey","key","getNextNodeDirection","currentDirection","currentCol","nextRow","nextCol","getGrowthNodeCoords","snakeTail","tailNextNodeDirection","growthDirection","getOppositeDirection","currentTailCoords","getCellClassName","cellValue","foodCell","foodShouldReverseDirection","snakeCells","className","has","Board","useState","score","setScore","snake","setSnake","Set","setSnakeCells","setFoodCell","setDirection","setFoodShouldReverseDirection","useEffect","window","addEventListener","e","handleKeydown","callback","delay","savedCallback","useRef","current","id","setInterval","clearInterval","useInterval","moveSnake","newDirection","size","currentHeadCoords","nextHeadCoords","handleGameOver","nextHeadCell","newHead","currentHead","newSnakeCells","delete","add","growSnake","reverseSnake","handleFoodConsumption","growthNodeCoords","newTailCell","newTail","currentTail","previousNode","currentNode","nextNode","reverseLinkedList","snakeHead","nextFoodCell","min","max","floor","random","nextFoodShouldReverseDirection","snakeLLStartingValue","map","rowIdx","cellIdx","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.3af1ba5d.chunk.js","sourcesContent":["import React, { useEffect, useState } from 'react';\r\nimport \r\n{\r\n    randomIntFromInterval,\r\n    reverseLinkedList,\r\n    useInterval,\r\n} from '../lib/utils.js';\r\n\r\nimport './Board.css';\r\n\r\nclass LinkedListNode \r\n{\r\n    constructor(value) \r\n    {\r\n        this.value = value;\r\n        this.next = null;\r\n    }\r\n}\r\n\r\nclass LinkedList\r\n{\r\n    constructor(value) \r\n    {\r\n        const node = new LinkedListNode(value);\r\n        this.head = node;\r\n        this.tail = node;\r\n    }\r\n}\r\n\r\nconst Direction = {\r\n    UP: 'UP',\r\n    RIGHT: 'RIGHT',\r\n    DOWN: 'DOWN',\r\n    LEFT: 'LEFT',\r\n};\r\n\r\nconst BOARD_SIZE = 15;\r\nconst PROBABILITY_OF_DIRECTION_REVERSAL_FOOD = 0.3;\r\n\r\nconst getStartingSnakeLLValue = board => {\r\n    const rowSize = board.length;\r\n    const colSize = board[0].length;\r\n    const startingRow = Math.round(rowSize / 3);\r\n    const startingCol = Math.round(colSize / 3);\r\n    const startingCell = board[startingRow][startingCol];\r\n    return {\r\n        row: startingRow,\r\n        col: startingCol,\r\n        cell: startingCell,\r\n    };\r\n};\r\n\r\nconst Board = () => {\r\n    const [score, setScore] = useState(0);\r\n    const [board, setBoard] = useState(createBoard(BOARD_SIZE));\r\n    const [snake, setSnake] = useState(\r\n        new LinkedList(getStartingSnakeLLValue(board)),\r\n    );\r\n    const [snakeCells, setSnakeCells] = useState(\r\n        new Set([snake.head.value.cell]),\r\n    );\r\n    // Naively set the starting food cell 5 cells away from the starting snake cell.\r\n    const [foodCell, setFoodCell] = useState(snake.head.value.cell + 5);\r\n    const [direction, setDirection] = useState(Direction.RIGHT);\r\n    const [foodShouldReverseDirection, setFoodShouldReverseDirection] = useState(\r\n        false,\r\n    );\r\n\r\n    useEffect(() => {\r\n        window.addEventListener('keydown', e => {\r\n            handleKeydown(e);\r\n        });\r\n    }, []);\r\n\r\n    // `useInterval` is needed; you can't naively do `setInterval` in the\r\n    // `useEffect` above. See the article linked above the `useInterval`\r\n    // definition for details.\r\n    useInterval(() => {\r\n        moveSnake();\r\n    }, 150);\r\n\r\n    const handleKeydown = e => {\r\n        const newDirection = getDirectionFromKey(e.key);\r\n        const isValidDirection = newDirection !== '';\r\n        if (!isValidDirection) return;\r\n        const snakeWillRunIntoItself =\r\n            getOppositeDirection(newDirection) === direction && snakeCells.size > 1;\r\n        // Note: this functionality is currently broken, for the same reason that\r\n        // `useInterval` is needed. Specifically, the `direction` and `snakeCells`\r\n        // will currently never reflect their \"latest version\" when `handleKeydown`\r\n        // is called. I leave it as an exercise to the viewer to fix this :P\r\n        if (snakeWillRunIntoItself) return;\r\n        setDirection(newDirection);\r\n    };\r\n\r\n    const moveSnake = () => {\r\n        const currentHeadCoords = {\r\n            row: snake.head.value.row,\r\n            col: snake.head.value.col,\r\n        };\r\n\r\n        const nextHeadCoords = getCoordsInDirection(currentHeadCoords, direction);\r\n        if (isOutOfBounds(nextHeadCoords, board)) {\r\n            handleGameOver();\r\n            return;\r\n        }\r\n        const nextHeadCell = board[nextHeadCoords.row][nextHeadCoords.col];\r\n        if (snakeCells.has(nextHeadCell)) {\r\n            handleGameOver();\r\n            return;\r\n        }\r\n\r\n        const newHead = new LinkedListNode({\r\n            row: nextHeadCoords.row,\r\n            col: nextHeadCoords.col,\r\n            cell: nextHeadCell,\r\n        });\r\n        const currentHead = snake.head;\r\n        snake.head = newHead;\r\n        currentHead.next = newHead;\r\n\r\n        const newSnakeCells = new Set(snakeCells);\r\n        newSnakeCells.delete(snake.tail.value.cell);\r\n        newSnakeCells.add(nextHeadCell);\r\n\r\n        snake.tail = snake.tail.next;\r\n        if (snake.tail === null) snake.tail = snake.head;\r\n\r\n        const foodConsumed = nextHeadCell === foodCell;\r\n        if (foodConsumed) {\r\n            // This function mutates newSnakeCells.\r\n            growSnake(newSnakeCells);\r\n            if (foodShouldReverseDirection) reverseSnake();\r\n            handleFoodConsumption(newSnakeCells);\r\n        }\r\n\r\n        setSnakeCells(newSnakeCells);\r\n    };\r\n\r\n    // This function mutates newSnakeCells.\r\n    const growSnake = newSnakeCells => {\r\n        const growthNodeCoords = getGrowthNodeCoords(snake.tail, direction);\r\n        if (isOutOfBounds(growthNodeCoords, board)) {\r\n            // Snake is positioned such that it can't grow; don't do anything.\r\n            return;\r\n        }\r\n        const newTailCell = board[growthNodeCoords.row][growthNodeCoords.col];\r\n        const newTail = new LinkedListNode({\r\n            row: growthNodeCoords.row,\r\n            col: growthNodeCoords.col,\r\n            cell: newTailCell,\r\n        });\r\n        const currentTail = snake.tail;\r\n        snake.tail = newTail;\r\n        snake.tail.next = currentTail;\r\n\r\n        newSnakeCells.add(newTailCell);\r\n    };\r\n\r\n    const reverseSnake = () => {\r\n        const tailNextNodeDirection = getNextNodeDirection(snake.tail, direction);\r\n        const newDirection = getOppositeDirection(tailNextNodeDirection);\r\n        setDirection(newDirection);\r\n\r\n        // The tail of the snake is really the head of the linked list, which\r\n        // is why we have to pass the snake's tail to `reverseLinkedList`.\r\n        reverseLinkedList(snake.tail);\r\n        const snakeHead = snake.head;\r\n        snake.head = snake.tail;\r\n        snake.tail = snakeHead;\r\n    };\r\n\r\n    const handleFoodConsumption = newSnakeCells => {\r\n        const maxPossibleCellValue = BOARD_SIZE * BOARD_SIZE;\r\n        let nextFoodCell;\r\n        // In practice, this will never be a time-consuming operation. Even\r\n        // in the extreme scenario where a snake is so big that it takes up 90%\r\n        // of the board (nearly impossible), there would be a 10% chance of generating\r\n        // a valid new food cell--so an average of 10 operations: trivial.\r\n        while (true) {\r\n            nextFoodCell = randomIntFromInterval(1, maxPossibleCellValue);\r\n            if (newSnakeCells.has(nextFoodCell) || foodCell === nextFoodCell)\r\n                continue;\r\n            break;\r\n        }\r\n\r\n        const nextFoodShouldReverseDirection =\r\n            Math.random() < PROBABILITY_OF_DIRECTION_REVERSAL_FOOD;\r\n\r\n        setFoodCell(nextFoodCell);\r\n        setFoodShouldReverseDirection(nextFoodShouldReverseDirection);\r\n        setScore(score + 1);\r\n    };\r\n\r\n    const handleGameOver = () => {\r\n        setScore(0);\r\n        const snakeLLStartingValue = getStartingSnakeLLValue(board);\r\n        setSnake(new LinkedList(snakeLLStartingValue));\r\n        setFoodCell(snakeLLStartingValue.cell + 5);\r\n        setSnakeCells(new Set([snakeLLStartingValue.cell]));\r\n        setDirection(Direction.RIGHT);\r\n    };\r\n\r\n    return (\r\n        <>\r\n            <h1>Score: {score}</h1>\r\n            <div className=\"board\">\r\n                {board.map((row, rowIdx) => (\r\n                    <div key={rowIdx} className=\"row\">\r\n                        {row.map((cellValue, cellIdx) => {\r\n                            const className = getCellClassName(\r\n                                cellValue,\r\n                                foodCell,\r\n                                foodShouldReverseDirection,\r\n                                snakeCells,\r\n                            );\r\n                            return <div key={cellIdx} className={className}></div>;\r\n                        })}\r\n                    </div>\r\n                ))}\r\n            </div>\r\n        </>\r\n    );\r\n};\r\n\r\nconst createBoard = BOARD_SIZE => {\r\n    let counter = 1;\r\n    const board = [];\r\n    for (let row = 0; row < BOARD_SIZE; row++) {\r\n        const currentRow = [];\r\n        for (let col = 0; col < BOARD_SIZE; col++) {\r\n            currentRow.push(counter++);\r\n        }\r\n        board.push(currentRow);\r\n    }\r\n    return board;\r\n};\r\n\r\nconst getCoordsInDirection = (coords, direction) => {\r\n    if (direction === Direction.UP) {\r\n        return {\r\n            row: coords.row - 1,\r\n            col: coords.col,\r\n        };\r\n    }\r\n    if (direction === Direction.RIGHT) {\r\n        return {\r\n            row: coords.row,\r\n            col: coords.col + 1,\r\n        };\r\n    }\r\n    if (direction === Direction.DOWN) {\r\n        return {\r\n            row: coords.row + 1,\r\n            col: coords.col,\r\n        };\r\n    }\r\n    if (direction === Direction.LEFT) {\r\n        return {\r\n            row: coords.row,\r\n            col: coords.col - 1,\r\n        };\r\n    }\r\n};\r\n\r\nconst isOutOfBounds = (coords, board) => {\r\n    const { row, col } = coords;\r\n    if (row < 0 || col < 0) return true;\r\n    if (row >= board.length || col >= board[0].length) return true;\r\n    return false;\r\n};\r\n\r\nconst getDirectionFromKey = key => {\r\n    if (key === 'ArrowUp') return Direction.UP;\r\n    if (key === 'ArrowRight') return Direction.RIGHT;\r\n    if (key === 'ArrowDown') return Direction.DOWN;\r\n    if (key === 'ArrowLeft') return Direction.LEFT;\r\n    return '';\r\n};\r\n\r\nconst getNextNodeDirection = (node, currentDirection) => {\r\n    if (node.next === null) return currentDirection;\r\n    const { row: currentRow, col: currentCol } = node.value;\r\n    const { row: nextRow, col: nextCol } = node.next.value;\r\n    if (nextRow === currentRow && nextCol === currentCol + 1) {\r\n        return Direction.RIGHT;\r\n    }\r\n    if (nextRow === currentRow && nextCol === currentCol - 1) {\r\n        return Direction.LEFT;\r\n    }\r\n    if (nextCol === currentCol && nextRow === currentRow + 1) {\r\n        return Direction.DOWN;\r\n    }\r\n    if (nextCol === currentCol && nextRow === currentRow - 1) {\r\n        return Direction.UP;\r\n    }\r\n    return '';\r\n};\r\n\r\nconst getGrowthNodeCoords = (snakeTail, currentDirection) => {\r\n    const tailNextNodeDirection = getNextNodeDirection(\r\n        snakeTail,\r\n        currentDirection,\r\n    );\r\n    const growthDirection = getOppositeDirection(tailNextNodeDirection);\r\n    const currentTailCoords = {\r\n        row: snakeTail.value.row,\r\n        col: snakeTail.value.col,\r\n    };\r\n    const growthNodeCoords = getCoordsInDirection(\r\n        currentTailCoords,\r\n        growthDirection,\r\n    );\r\n    return growthNodeCoords;\r\n};\r\n\r\nconst getOppositeDirection = direction => {\r\n    if (direction === Direction.UP) return Direction.DOWN;\r\n    if (direction === Direction.RIGHT) return Direction.LEFT;\r\n    if (direction === Direction.DOWN) return Direction.UP;\r\n    if (direction === Direction.LEFT) return Direction.RIGHT;\r\n};\r\n\r\nconst getCellClassName = (\r\n    cellValue,\r\n    foodCell,\r\n    foodShouldReverseDirection,\r\n    snakeCells,\r\n) => {\r\n    let className = 'cell';\r\n    if (cellValue === foodCell) {\r\n        if (foodShouldReverseDirection) {\r\n            className = 'cell cell-purple';\r\n        } else {\r\n            className = 'cell cell-red';\r\n        }\r\n    }\r\n    if (snakeCells.has(cellValue)) className = 'cell cell-green';\r\n\r\n    return className;\r\n};\r\n\r\nexport default Board;","import { useEffect, useRef } from 'react';\r\n\r\nexport function randomIntFromInterval(min, max) { // min and max included \r\n    return Math.floor(Math.random() * (max - min + 1) + min)\r\n}\r\n\r\nexport function useInterval(callback, delay) {\r\n    const savedCallback = useRef();\r\n    useEffect(() => {\r\n        savedCallback.current = callback;\r\n    }, [callback]);\r\n\r\n    // Set up the interval.\r\n    useEffect(() => {\r\n        function tick() {\r\n            savedCallback.current();\r\n        }\r\n        if (delay !== null) {\r\n            let id = setInterval(tick, delay);\r\n            return () => clearInterval(id);\r\n        }\r\n    }, [delay]);\r\n}\r\n\r\nexport function reverseLinkedList(head) {\r\n    let previousNode = null;\r\n    let currentNode = head;\r\n    while (currentNode !== null) {\r\n        const nextNode = currentNode.next;\r\n        currentNode.next = previousNode;\r\n        previousNode = currentNode;\r\n        currentNode = nextNode;\r\n    }\r\n    return previousNode;\r\n}","import './App.css';\nimport Board from './Board/Board.jsx';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Board/>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}